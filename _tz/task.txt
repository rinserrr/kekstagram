/*
    2.18. Нужно больше функций


    Функция, возвращающая случайное целое число из переданного диапазона включительно.
    Пример использования функции:
    имя_функции(от, до); // Результат: целое число из диапазона "от...до"

    Учтите, что аргументами функции могут быть только положительные числа и ноль.
    Если функции пришли неправильные аргументы, она должна вернуть NaN (о том, что это такое, говорилось в учебнике).

    Придумайте, как функция будет вести себя, если передать значение «до» меньшее, чем значение «от», или равное ему.
    Например, в этом случае функция также может возвращать NaN. Или же вы можете проверить, какой из аргументов больше,
    а какой меньше, и при необходимости поменять их местами. Возможны и другие варианты.

    Функция может не гарантировать верный результат, если в переданном диапазоне нет ни одного подходящего числа.
*/


/*
    4.15. Больше деталей


    В файле main.js на основе написанных по заданию ранее вспомогательных функций напишите необходимые функции для создания массива из 25 сгенерированных объектов. Каждый объект массива — описание фотографии, опубликованной пользователем.

    Структура каждого объекта должна быть следующей:

    id, число — идентификатор опубликованной фотографии. Это число от 1 до 25. Идентификаторы не должны повторяться.

    url, строка — адрес картинки вида photos/{{i}}.jpg, где {{i}} — это число от 1 до 25. Адреса картинок не должны повторяться.

    description, строка — описание фотографии. Описание придумайте самостоятельно.

    likes, число — количество лайков, поставленных фотографии. Случайное число от 15 до 200.

    comments, массив объектов — список комментариев, оставленных другими пользователями к этой фотографии. Количество комментариев к каждой фотографии вы определяете на своё усмотрение. Все комментарии генерируются случайным образом. Пример описания объекта с комментарием:

    {
    id: 135,
    avatar: 'img/avatar-6.svg',
    message: 'В целом всё неплохо. Но не всё.',
    name: 'Артём',
    }

    У каждого комментария есть идентификатор — id — случайное число. Идентификаторы не должны повторяться.

    Поле avatar — это строка, значение которой формируется по правилу img/avatar-{{случайное число от 1 до 6}}.svg. Аватарки подготовлены в директории img.

    Для формирования текста комментария — message — вам необходимо взять одно или два случайных предложения из представленных ниже:

    Всё отлично!
    В целом всё неплохо. Но не всё.
    Когда вы делаете фотографию, хорошо бы убирать палец из кадра. В конце концов это просто непрофессионально.
    Моя бабушка случайно чихнула с фотоаппаратом в руках и у неё получилась фотография лучше.
    Я поскользнулся на банановой кожуре и уронил фотоаппарат на кота и у меня получилась фотография лучше.
    Лица у людей на фотке перекошены, как будто их избивают. Как можно было поймать такой неудачный момент?!


    Имена авторов также должны быть случайными. Набор имён для комментаторов составьте сами. Подставляйте случайное имя в поле name.
*/


/*
    5.16. Модуляция


    Задача

    Разделите код, уже написанный в main.js, на отдельные ES2015-модули. main.js станет главным модулем, точкой входа. В этом файле должны остаться только импорты других модулей, а также код, который необходим для их работы.

    Пример разбиения на модули
    main.js — точка входа. Модуль, который связывает другие модули;
    util.js — модуль с вспомогательными функциями;
    data.js — модуль, который создаёт данные.
    Указанное выше разделение на модули — это только пример. Вы можете разделить код на модули так, как считаете нужным.

    Импортируйте нужные модули в точку входа, а точку входа подключите в index.html как скрипт-модуль.

    По желанию, вы можете перечитать техническое задание и подумать, какие ещё модули потребуются в приложении, а после завести под них пустые файлы, чтобы сразу обозначить файловую структуру проекта.
*/


/*
    7.16. Отрисуй меня полностью (часть 1)


    Задача

    Обратите внимание, в тексте задания вы будете встречать текст в фигурных скобках. Такой текст будет означать, что на месте этого текста должно появиться значение, которое вы возьмёте из данных. Например, в шаблоне может быть написано <div>{{x}}</div>, и это будет значить, что {{x}} нужно заменить на значение переменной x. Если переменная будет равна 100, то разметка должна выглядеть как <div>100</div>. Фигурные скобки в этой записи ничего не значат, они просто показывают, что закончилась разметка и в этом месте будут стоять данные. Сами фигурные скобки переносить в разметку не нужно.


    Отобразить фотографии других пользователей.

    1. Заведите модуль, который будет отвечать за отрисовку миниатюр.

    2. На основе временных данных для разработки и шаблона #picture создайте DOM-элементы, соответствующие фотографиям, и заполните их данными:
        Адрес изображения url подставьте как атрибут src изображения.
        Количество лайков likes выведите в блок .picture__likes.
        Количество комментариев comments выведите в блок .picture__comments.

    3.  Отрисуйте сгенерированные DOM-элементы в блок .pictures. Для вставки элементов используйте DocumentFragment.

    4. Подключите модуль в проект.
*/


/*
    7.17. Отрисуй меня полностью (часть 2) — для сложных проектов


    Задача

    Реализовать сценарий просмотра фотографий в полноразмерном режиме. В таком режиме пользователь получает несколько дополнительных возможностей: детально рассмотреть изображение, поставить «лайк», почитать комментарии, оставленные другими пользователями.

    1. Заведите модуль, который будет отвечать за отрисовку окна с полноразмерным изображением.

    2. Для отображения окна нужно удалять класс hidden у элемента .big-picture и каждый раз заполнять его
        данными о конкретной фотографии:

        Адрес изображения url подставьте как src изображения внутри блока .big-picture__img.

        Количество лайков likes подставьте как текстовое содержание элемента .likes-count.

        Количество комментариев comments подставьте как текстовое содержание элемента .comments-count.

        Список комментариев под фотографией: комментарии должны вставляться в блок .social__comments. Разметка каждого комментария должна выглядеть так:
        <li class="social__comment">
            <img
                class="social__picture"
                src="{{аватар}}"
                alt="{{имя комментатора}}"
                width="35" height="35">
            <p class="social__text">{{текст комментария}}</p>
        </li>

        Описание фотографии description вставьте строкой в блок .social__caption.

    3. После открытия окна спрячьте блоки счётчика комментариев .social__comment-count и загрузки новых
       комментариев .comments-loader, добавив им класс hidden, с ними мы разберёмся позже, в другом домашнем задании.

    4. После открытия окна добавьте тегу <body> класс modal-open, чтобы контейнер с фотографиями позади не
       прокручивался при скролле. При закрытии окна не забудьте удалить этот класс.

    5. Напишите код для закрытия окна по нажатию клавиши Esc и клике по иконке закрытия.

    6. Подключите модуль в проект.


    Как связать модули миниатюр и полноразмерного режима?

    Задача не имеет одного верного решения, поэтому будет правильным как использование третьего модуля для связки двух других, так и импорт модуля полноразмерных изображений в модуль миниатюр и дальнейшая работа с интерфейсом этого модуля, addEventListener и замыканиями. Последнее решение похоже на демонстрацию по учебному проекту. А первое — с третьим модулем — более сложное из-за отсутствия примера, но самостоятельное. В качестве третьего модуля можно выбрать точку входа, а можно завести отдельный модуль, например «Галерея». Решение за вами.
*/


/*
    8.21. Правда или действие (часть 1)


    Задача

    Добавить в проект валидацию, проверки введённых данных, чтобы подсказать пользователю, какие данные мы от него ждём, а себе и бэкендеру упростить работу с этими данными.

    1. Заведите модуль, который будет отвечать за работу с формой.

    2. Пропишите тегу <form> правильные значения атрибутов method и адрес action для отправки формы на сервер.
        Загрузка изображений от других пользователей производится сразу после открытия страницы с удалённого сервера: https://27.javascript.pages.academy/kekstagram/data

        Обратите внимание. В разделе про работу с сетью мы доработаем механизм отправки данных, а пока достаточно правильных атрибутов у тега <form>.

        Если форма заполнена верно, то после отправки покажется страница сервера (по адресу из атрибута action тега form) с успешно отправленными данными. Если же форма пропустила какие-то некорректные значения, то будет показана страница с допущенными ошибками. В идеале у пользователя не должно быть сценария, при котором он может отправить некорректную форму.

    3. Проверьте разметку вашего проекта и добавьте недостающие атрибуты. Например, всем обязательным полям нужно добавить атрибут required. Затем проверьте, правильные ли типы стоят у нужных полей, если нет — проставьте правильные.

    4. Изучите, что значит загрузка изображения, и как, когда и каким образом показывается форма редактирования изображения.
        Напишите код и добавьте необходимые обработчики для реализации этого пункта техзадания. В работе вы можете опираться на код показа окна с полноразмерной фотографией, который вы, возможно, уже написали в предыдущей домашней работе.


        2. Редактирование изображения и ограничения, накладываемые на поля

        2.1. Масштаб:
        При нажатии на кнопки .scale__control--smaller и .scale__control--bigger должно изменяться значение поля .scale__control--value;
        Значение должно изменяться с шагом в 25. Например, если значение поля установлено в 50%, после нажатия на «+», значение должно стать равным 75%. Максимальное значение — 100%, минимальное — 25%. Значение по умолчанию — 100%;
        При изменении значения поля .scale__control--value изображению внутри .img-upload__preview должен добавляться соответствующий стиль CSS, который с помощью трансформации scale задаёт масштаб. Например, если в поле стоит значение 75%, то в стиле изображения должно быть написано transform: scale(0.75).

        2.2. Наложение эффекта на изображение:
        По умолчанию должен быть выбран эффект «Оригинал».
        На изображение может накладываться только один эффект.
        При смене эффекта, выбором одного из значений среди радиокнопок .effects__radio, добавить картинке внутри .img-upload__preview CSS-класс, соответствующий эффекту. Например, если выбран эффект .effect-chrome, изображению нужно добавить класс effects__preview--chrome.
        Интенсивность эффекта регулируется перемещением ползунка в слайдере. Слайдер реализуется сторонней библиотекой для реализации слайдеров noUiSlider. Уровень эффекта записывается в поле .effect-level__value. При изменении уровня интенсивности эффекта (предоставляется API слайдера), CSS-стили картинки внутри .img-upload__preview обновляются следующим образом:
        Для эффекта «Хром» — filter: grayscale(0..1) с шагом 0.1;
        Для эффекта «Сепия» — filter: sepia(0..1) с шагом 0.1;
        Для эффекта «Марвин» — filter: invert(0..100%) с шагом 1%;
        Для эффекта «Фобос» — filter: blur(0..3px) с шагом 0.1px;
        Для эффекта «Зной» — filter: brightness(1..3) с шагом 0.1;
        Для эффекта «Оригинал» CSS-стили filter удаляются.
        При выборе эффекта «Оригинал» слайдер скрывается.
        При переключении эффектов, уровень насыщенности сбрасывается до начального значения (100%): слайдер, CSS-стиль изображения и значение поля должны обновляться.


        3. Отправка данных на сервер
        3.1. После заполнения всех данных, при нажатии на кнопку «Отправить», все данные из формы, включая изображения, с помощью AJAX-запроса отправляются на сервер https://27.javascript.pages.academy/kekstagram методом POST с типом multipart/form-data.
        На время выполнения запроса к серверу кнопка «Отправить» блокируется.

        3.2. Страница реагирует на неправильно введённые значения в форму. Если данные, введённые в форму, не соответствуют ограничениям, указанным в пунктах 2.3 и 2.4, форму невозможно отправить на сервер. При попытке отправить форму с неправильными данными, отправки не происходит, а пользователю показываются ошибки для неверно заполненных полей (для проверки данных используется сторонняя библиотека Pristine).

        3.3. При успешной отправке формы форма редактирования изображения закрывается, все данные, введённые в форму, и контрол фильтра приходят в исходное состояние:

        масштаб возвращается к 100%;
        эффект сбрасывается на «Оригинал»;
        поля для ввода хэш-тегов и комментария очищаются;
        поле загрузки фотографии, стилизованное под букву «О» в логотипе, очищается.

        3.4. Если отправка данных прошла успешно, показывается соответствующее сообщение. Разметку сообщения, которая находится в блоке #success внутри шаблона template, нужно разместить перед закрывающим тегом </body>. Сообщение должно исчезать после нажатия на кнопку .success__button, по нажатию на клавишу Esc и по клику на произвольную область экрана за пределами блока с сообщением.

        3.5. Если при отправке данных произошла ошибка запроса, нужно показать соответствующее сообщение. Разметку сообщения, которая находится в блоке #error внутри шаблона template, нужно разместить перед закрывающим тегом </body>. Сообщение должно исчезать после нажатия на кнопку .error__button, по нажатию на клавишу Esc и по клику на произвольную область экрана за пределами блока с сообщением. В таком случае вся введённая пользователем информация сохраняется, чтобы у него была возможность отправить форму повторно.

        3.6. Нажатие на кнопку #upload-cancel приводит к закрытию формы и возвращению всех данных и контрола фильтра к исходному состоянию (описано в пункте 3.3). Поле загрузки фотографии, стилизованное под букву «О» в логотипе, очищается.

    5. После реализуйте закрытие формы.

    6. Напишите код для валидации формы добавления изображения, используя библиотеку Pristine (/vendor/pristine). Список полей для валидации:

        - Хэш-теги

          2.3. Хэш-теги:
          хэш-тег начинается с символа # (решётка);
          строка после решётки должна состоять из букв и чисел и не может содержать пробелы, спецсимволы (#, @, $ и т. п.), символы пунктуации (тире, дефис, запятая и т. п.), эмодзи и т. д.;
          хеш-тег не может состоять только из одной решётки;
          максимальная длина одного хэш-тега 20 символов, включая решётку;
          хэш-теги нечувствительны к регистру: #ХэшТег и #хэштег считаются одним и тем же тегом;
          хэш-теги разделяются пробелами;
          один и тот же хэш-тег не может быть использован дважды;
          нельзя указать больше пяти хэш-тегов;
          хэш-теги необязательны;
          если фокус находится в поле ввода хэш-тега, нажатие на Esc не должно приводить к закрытию формы редактирования изображения.

        - Комментарий

          2.4. Комментарий:
          - комментарий не обязателен;
          - длина комментария не может составлять больше 140 символов;
          - если фокус находится в поле ввода комментария, нажатие на Esc не должно приводить к закрытию формы редактирования изображения.

    7. Реализуйте логику проверки так, чтобы, как минимум, она срабатывала при попытке отправить форму и не давала этого сделать,
        если форма заполнена не по правилам. При желании, реализуйте проверки сразу при вводе значения в поле.


    Как отменить обработчик Esc при фокусе?
    Задача не имеет одного верного решения, однако намекнём на самый простой — использовать stopPropagation
    для события нажатия клавиш в поле при фокусе.


    Валидация хеш-тегов?
    Для валидации хэш-тегов вам придётся вспомнить, как работать с массивами. Набор хэш-тегов можно превратить в массив, воспользовавшись методом .split(). Он разбивает строки на массивы. После этого, вы можете написать цикл, который будет ходить по полученному массиву и проверять каждый из хэш-тегов на предмет соответствия ограничениям. Если хотя бы один из тегов не проходит нужных проверок, показывать сообщение об ошибке.


    Поля, не перечисленные в техзадании, но существующие в разметке, особой валидации не требуют.
*/


/*
    8.22. Правда или действие (часть 2) — для сложных проектов


    Задача

    Каждый объект с описанием фотографии содержит массив с комментариями. Данные из этого массива мы вывели в соответствующую область окна полноразмерного просмотра. Все бы хорошо, но для популярных фотографий комментариев может быть много. Если вывести их разом, то пользователю будет неудобно взаимодействовать с окном просмотра. Улучшить пользовательский интерфейс поможет кнопка «Загрузить ещё».

    Покажите блоки счётчика комментариев .social__comment-count и загрузки новых комментариев .comments-loader, убрав у них класс hidden.

    В модуле, который отвечает за отрисовку окна с полноразмерным изображением, доработайте код по выводу списка комментариев таким образом, чтобы список показывался не полностью, а по 5 элементов, и следующие 5 элементов добавлялись бы по нажатию на кнопку «Загрузить ещё». Не забудьте реализовать обновление числа показанных комментариев в блоке .social__comment-count.

    Обратите внимание, хотя кнопка называется «Загрузить ещё», никакой загрузки с сервера не происходит. Просто показываются следующие 5 комментариев из списка.
*/


/*
    9.8. Помощь друга


    Задача

    В этом задании мы продолжим реализацию сценария загрузки изображения и его редактирования на примере заглушки.

      1. Напишите код, который позволит пользователю редактировать масштаб изображения. Кроме визуального применения эффекта необходимо записывать значение в поле формы с масштабом, доступное только для чтения, для дальнейшей отправки на сервер.

      2. С помощью библиотеки noUiSlider (/vendor/nouislider) реализуйте применение эффекта для изображения. Кроме визуального применения эффекта необходимо записывать значение в скрытое поле для дальнейшей отправки на сервер.


          Обратите внимание, что при переключении фильтра, уровень эффекта должен сразу сбрасываться до начального состояния, т. е. логика по определению уровня насыщенности должна срабатывать не только при «перемещении» слайдера, но и при переключении фильтров.
*/
